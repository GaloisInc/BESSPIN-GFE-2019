//
// Generated by Bluespec Compiler, version 2017.07.A (build e1df8052c, 2017-07-21)
//
//
//
//
// Ports:
// Name                         I/O  size props
// axi_in_tready                  O     1 reg
// comms_link_request_get         O   656 reg
// RDY_comms_link_request_get     O     1 reg
// RDY_comms_link_response_put    O     1 reg
// CLK_uclk                       O     1
// CLK_GATE_uclk                  O     1 const
// RST_N_urstn                    O     1
// CLK                            I     1
// RST_N                          I     1
// axi_in_tvalid                  I     1
// axi_in_tdata                   I   608 reg
// axi_in_tstrb                   I    76 reg
// axi_in_tkeep                   I    76 reg
// axi_in_tlast                   I     1 reg
// comms_link_response_put        I   176 reg
// EN_comms_link_response_put     I     1
// EN_comms_link_request_get      I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkDut(CLK,
	     RST_N,

	     axi_in_tvalid,
	     axi_in_tdata,
	     axi_in_tstrb,
	     axi_in_tkeep,
	     axi_in_tlast,

	     axi_in_tready,

	     EN_comms_link_request_get,
	     comms_link_request_get,
	     RDY_comms_link_request_get,

	     comms_link_response_put,
	     EN_comms_link_response_put,
	     RDY_comms_link_response_put,

	     CLK_uclk,
	     CLK_GATE_uclk,

	     RST_N_urstn);
  input  CLK;
  input  RST_N;

  // action method axi_in_m_tvalid
  input  axi_in_tvalid;
  input  [607 : 0] axi_in_tdata;
  input  [75 : 0] axi_in_tstrb;
  input  [75 : 0] axi_in_tkeep;
  input  axi_in_tlast;

  // value method axi_in_m_tready
  output axi_in_tready;

  // actionvalue method comms_link_request_get
  input  EN_comms_link_request_get;
  output [655 : 0] comms_link_request_get;
  output RDY_comms_link_request_get;

  // action method comms_link_response_put
  input  [175 : 0] comms_link_response_put;
  input  EN_comms_link_response_put;
  output RDY_comms_link_response_put;

  // oscillator and gates for output clock CLK_uclk
  output CLK_uclk;
  output CLK_GATE_uclk;

  // output resets
  output RST_N_urstn;

  // signals for module outputs
  wire [655 : 0] comms_link_request_get;
  wire CLK_GATE_uclk,
       CLK_uclk,
       RDY_comms_link_request_get,
       RDY_comms_link_response_put,
       RST_N_urstn,
       axi_in_tready;

  // register rg_started
  reg rg_started;
  wire rg_started$D_IN, rg_started$EN;

  // ports of submodule axis_xactor_f_data
  wire [760 : 0] axis_xactor_f_data$D_IN, axis_xactor_f_data$D_OUT;
  wire axis_xactor_f_data$CLR,
       axis_xactor_f_data$DEQ,
       axis_xactor_f_data$EMPTY_N,
       axis_xactor_f_data$ENQ,
       axis_xactor_f_data$FULL_N;

  // ports of submodule bytevec_mux
  wire [655 : 0] bytevec_mux$client_request_get;
  wire [607 : 0] bytevec_mux$to_verifier_put;
  wire [175 : 0] bytevec_mux$client_response_put;
  wire bytevec_mux$EN_client_request_get,
       bytevec_mux$EN_client_response_put,
       bytevec_mux$EN_from_console_get,
       bytevec_mux$EN_init,
       bytevec_mux$EN_to_verifier_put,
       bytevec_mux$RDY_client_request_get,
       bytevec_mux$RDY_client_response_put,
       bytevec_mux$RDY_to_verifier_put;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_start,
       CAN_FIRE_RL_tandem_cnx_mkConnectionAVtoAf,
       CAN_FIRE_axi_in_m_tvalid,
       CAN_FIRE_comms_link_request_get,
       CAN_FIRE_comms_link_response_put,
       WILL_FIRE_RL_rl_start,
       WILL_FIRE_RL_tandem_cnx_mkConnectionAVtoAf,
       WILL_FIRE_axi_in_m_tvalid,
       WILL_FIRE_comms_link_request_get,
       WILL_FIRE_comms_link_response_put;

  // oscillator and gates for output clock CLK_uclk
  assign CLK_uclk = CLK ;
  assign CLK_GATE_uclk = 1'd1 ;

  // output resets
  assign RST_N_urstn = RST_N ;

  // action method axi_in_m_tvalid
  assign CAN_FIRE_axi_in_m_tvalid = 1'd1 ;
  assign WILL_FIRE_axi_in_m_tvalid = 1'd1 ;

  // value method axi_in_m_tready
  assign axi_in_tready = axis_xactor_f_data$FULL_N ;

  // actionvalue method comms_link_request_get
  assign comms_link_request_get = bytevec_mux$client_request_get ;
  assign RDY_comms_link_request_get = bytevec_mux$RDY_client_request_get ;
  assign CAN_FIRE_comms_link_request_get =
	     bytevec_mux$RDY_client_request_get ;
  assign WILL_FIRE_comms_link_request_get = EN_comms_link_request_get ;

  // action method comms_link_response_put
  assign RDY_comms_link_response_put = bytevec_mux$RDY_client_response_put ;
  assign CAN_FIRE_comms_link_response_put =
	     bytevec_mux$RDY_client_response_put ;
  assign WILL_FIRE_comms_link_response_put = EN_comms_link_response_put ;

  // submodule axis_xactor_f_data
  FIFO2 #(.width(32'd761), .guarded(32'd1)) axis_xactor_f_data(.RST(RST_N),
							       .CLK(CLK),
							       .D_IN(axis_xactor_f_data$D_IN),
							       .ENQ(axis_xactor_f_data$ENQ),
							       .DEQ(axis_xactor_f_data$DEQ),
							       .CLR(axis_xactor_f_data$CLR),
							       .D_OUT(axis_xactor_f_data$D_OUT),
							       .FULL_N(axis_xactor_f_data$FULL_N),
							       .EMPTY_N(axis_xactor_f_data$EMPTY_N));

  // submodule bytevec_mux
  mkBytevec_Mux_HW_Side bytevec_mux(.CLK(CLK),
				    .RST_N(RST_N),
				    .client_response_put(bytevec_mux$client_response_put),
				    .to_verifier_put(bytevec_mux$to_verifier_put),
				    .EN_init(bytevec_mux$EN_init),
				    .EN_client_request_get(bytevec_mux$EN_client_request_get),
				    .EN_client_response_put(bytevec_mux$EN_client_response_put),
				    .EN_from_console_get(bytevec_mux$EN_from_console_get),
				    .EN_to_verifier_put(bytevec_mux$EN_to_verifier_put),
				    .RDY_init(),
				    .shutdown(),
				    .RDY_shutdown(),
				    .client_request_get(bytevec_mux$client_request_get),
				    .RDY_client_request_get(bytevec_mux$RDY_client_request_get),
				    .RDY_client_response_put(bytevec_mux$RDY_client_response_put),
				    .from_console_get(),
				    .RDY_from_console_get(),
				    .RDY_to_verifier_put(bytevec_mux$RDY_to_verifier_put));

  // rule RL_tandem_cnx_mkConnectionAVtoAf
  assign CAN_FIRE_RL_tandem_cnx_mkConnectionAVtoAf =
	     bytevec_mux$RDY_to_verifier_put && axis_xactor_f_data$EMPTY_N ;
  assign WILL_FIRE_RL_tandem_cnx_mkConnectionAVtoAf =
	     CAN_FIRE_RL_tandem_cnx_mkConnectionAVtoAf ;

  // rule RL_rl_start
  assign CAN_FIRE_RL_rl_start = !rg_started ;
  assign WILL_FIRE_RL_rl_start = CAN_FIRE_RL_rl_start ;

  // register rg_started
  assign rg_started$D_IN = 1'd1 ;
  assign rg_started$EN = CAN_FIRE_RL_rl_start ;

  // submodule axis_xactor_f_data
  assign axis_xactor_f_data$D_IN =
	     { axi_in_tdata, axi_in_tstrb, axi_in_tkeep, axi_in_tlast } ;
  assign axis_xactor_f_data$ENQ = axi_in_tvalid && axis_xactor_f_data$FULL_N ;
  assign axis_xactor_f_data$DEQ = CAN_FIRE_RL_tandem_cnx_mkConnectionAVtoAf ;
  assign axis_xactor_f_data$CLR = 1'b0 ;

  // submodule bytevec_mux
  assign bytevec_mux$client_response_put = comms_link_response_put ;
  assign bytevec_mux$to_verifier_put = axis_xactor_f_data$D_OUT[760:153] ;
  assign bytevec_mux$EN_init = CAN_FIRE_RL_rl_start ;
  assign bytevec_mux$EN_client_request_get = EN_comms_link_request_get ;
  assign bytevec_mux$EN_client_response_put = EN_comms_link_response_put ;
  assign bytevec_mux$EN_from_console_get = 1'b0 ;
  assign bytevec_mux$EN_to_verifier_put =
	     CAN_FIRE_RL_tandem_cnx_mkConnectionAVtoAf ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_started <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rg_started$EN)
	  rg_started <= `BSV_ASSIGNMENT_DELAY rg_started$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_started = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkDut

