//
// Generated by Bluespec Compiler, version 2017.07.A (build e1df8052c, 2017-07-21)
//
//
//
//
// Ports:
// Name                         I/O  size props
// RDY_init                       O     1 const
// shutdown                       O     1 reg
// RDY_shutdown                   O     1 const
// client_request_get             O   656 reg
// RDY_client_request_get         O     1 reg
// RDY_client_response_put        O     1 reg
// from_console_get               O     8 reg
// RDY_from_console_get           O     1 reg
// RDY_to_verifier_put            O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// client_response_put            I   176 reg
// to_verifier_put                I   608 reg
// EN_init                        I     1
// EN_client_response_put         I     1
// EN_to_verifier_put             I     1
// EN_client_request_get          I     1
// EN_from_console_get            I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBytevec_Mux_HW_Side(CLK,
			     RST_N,

			     EN_init,
			     RDY_init,

			     shutdown,
			     RDY_shutdown,

			     EN_client_request_get,
			     client_request_get,
			     RDY_client_request_get,

			     client_response_put,
			     EN_client_response_put,
			     RDY_client_response_put,

			     EN_from_console_get,
			     from_console_get,
			     RDY_from_console_get,

			     to_verifier_put,
			     EN_to_verifier_put,
			     RDY_to_verifier_put);
  input  CLK;
  input  RST_N;

  // action method init
  input  EN_init;
  output RDY_init;

  // value method shutdown
  output shutdown;
  output RDY_shutdown;

  // actionvalue method client_request_get
  input  EN_client_request_get;
  output [655 : 0] client_request_get;
  output RDY_client_request_get;

  // action method client_response_put
  input  [175 : 0] client_response_put;
  input  EN_client_response_put;
  output RDY_client_response_put;

  // actionvalue method from_console_get
  input  EN_from_console_get;
  output [7 : 0] from_console_get;
  output RDY_from_console_get;

  // action method to_verifier_put
  input  [607 : 0] to_verifier_put;
  input  EN_to_verifier_put;
  output RDY_to_verifier_put;

  // signals for module outputs
  wire [655 : 0] client_request_get;
  wire [7 : 0] from_console_get;
  wire RDY_client_request_get,
       RDY_client_response_put,
       RDY_from_console_get,
       RDY_init,
       RDY_shutdown,
       RDY_to_verifier_put,
       shutdown;

  // register credit_timeout_ctr
  reg [19 : 0] credit_timeout_ctr;
  wire [19 : 0] credit_timeout_ctr$D_IN;
  wire credit_timeout_ctr$EN;

  // register rg_avail_f_from_console
  reg [7 : 0] rg_avail_f_from_console;
  reg [7 : 0] rg_avail_f_from_console$D_IN;
  wire rg_avail_f_from_console$EN;

  // register rg_credits_to_verifier
  reg [7 : 0] rg_credits_to_verifier;
  reg [7 : 0] rg_credits_to_verifier$D_IN;
  wire rg_credits_to_verifier$EN;

  // register rg_shutdown
  reg rg_shutdown;
  wire rg_shutdown$D_IN, rg_shutdown$EN;

  // register test_succeeded
  reg test_succeeded;
  wire test_succeeded$D_IN, test_succeeded$EN;

  // ports of submodule f_bytevec_from_host
  wire [175 : 0] f_bytevec_from_host$D_IN, f_bytevec_from_host$D_OUT;
  wire f_bytevec_from_host$CLR,
       f_bytevec_from_host$DEQ,
       f_bytevec_from_host$EMPTY_N,
       f_bytevec_from_host$ENQ,
       f_bytevec_from_host$FULL_N;

  // ports of submodule f_bytevec_to_host
  reg [655 : 0] f_bytevec_to_host$D_IN;
  wire [655 : 0] f_bytevec_to_host$D_OUT;
  wire f_bytevec_to_host$CLR,
       f_bytevec_to_host$DEQ,
       f_bytevec_to_host$EMPTY_N,
       f_bytevec_to_host$ENQ,
       f_bytevec_to_host$FULL_N;

  // ports of submodule f_echo
  wire [7 : 0] f_echo$D_IN, f_echo$D_OUT;
  wire f_echo$CLR, f_echo$DEQ, f_echo$EMPTY_N, f_echo$ENQ, f_echo$FULL_N;

  // ports of submodule f_from_console
  wire [7 : 0] f_from_console$D_IN, f_from_console$D_OUT;
  wire f_from_console$CLR,
       f_from_console$DEQ,
       f_from_console$EMPTY_N,
       f_from_console$ENQ,
       f_from_console$FULL_N;

  // ports of submodule f_to_verifier
  wire [607 : 0] f_to_verifier$D_IN, f_to_verifier$D_OUT;
  wire f_to_verifier$CLR,
       f_to_verifier$DEQ,
       f_to_verifier$EMPTY_N,
       f_to_verifier$ENQ,
       f_to_verifier$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_rx_echo,
       CAN_FIRE_RL_rl_rx_from_console,
       CAN_FIRE_RL_rl_tx_credit,
       CAN_FIRE_RL_rl_tx_echo,
       CAN_FIRE_RL_rl_tx_to_verifier,
       CAN_FIRE_client_request_get,
       CAN_FIRE_client_response_put,
       CAN_FIRE_from_console_get,
       CAN_FIRE_init,
       CAN_FIRE_to_verifier_put,
       WILL_FIRE_RL_rl_rx_echo,
       WILL_FIRE_RL_rl_rx_from_console,
       WILL_FIRE_RL_rl_tx_credit,
       WILL_FIRE_RL_rl_tx_echo,
       WILL_FIRE_RL_rl_tx_to_verifier,
       WILL_FIRE_client_request_get,
       WILL_FIRE_client_response_put,
       WILL_FIRE_from_console_get,
       WILL_FIRE_init,
       WILL_FIRE_to_verifier_put;

  // inputs to muxes for submodule ports
  wire [655 : 0] MUX_f_bytevec_to_host$enq_1__VAL_1,
		 MUX_f_bytevec_to_host$enq_1__VAL_2,
		 MUX_f_bytevec_to_host$enq_1__VAL_3;
  wire [19 : 0] MUX_credit_timeout_ctr$write_1__VAL_1;
  wire [7 : 0] MUX_rg_avail_f_from_console$write_1__VAL_5,
	       MUX_rg_credits_to_verifier$write_1__VAL_2,
	       MUX_rg_credits_to_verifier$write_1__VAL_3;
  wire MUX_f_bytevec_to_host$enq_1__SEL_1;

  // action method init
  assign RDY_init = 1'd1 ;
  assign CAN_FIRE_init = 1'd1 ;
  assign WILL_FIRE_init = EN_init ;

  // value method shutdown
  assign shutdown = rg_shutdown ;
  assign RDY_shutdown = 1'd1 ;

  // actionvalue method client_request_get
  assign client_request_get = f_bytevec_to_host$D_OUT ;
  assign RDY_client_request_get = f_bytevec_to_host$EMPTY_N ;
  assign CAN_FIRE_client_request_get = f_bytevec_to_host$EMPTY_N ;
  assign WILL_FIRE_client_request_get = EN_client_request_get ;

  // action method client_response_put
  assign RDY_client_response_put = f_bytevec_from_host$FULL_N ;
  assign CAN_FIRE_client_response_put = f_bytevec_from_host$FULL_N ;
  assign WILL_FIRE_client_response_put = EN_client_response_put ;

  // actionvalue method from_console_get
  assign from_console_get = f_from_console$D_OUT ;
  assign RDY_from_console_get = f_from_console$EMPTY_N ;
  assign CAN_FIRE_from_console_get = f_from_console$EMPTY_N ;
  assign WILL_FIRE_from_console_get = EN_from_console_get ;

  // action method to_verifier_put
  assign RDY_to_verifier_put = f_to_verifier$FULL_N ;
  assign CAN_FIRE_to_verifier_put = f_to_verifier$FULL_N ;
  assign WILL_FIRE_to_verifier_put = EN_to_verifier_put ;

  // submodule f_bytevec_from_host
  FIFO2 #(.width(32'd176), .guarded(32'd1)) f_bytevec_from_host(.RST(RST_N),
								.CLK(CLK),
								.D_IN(f_bytevec_from_host$D_IN),
								.ENQ(f_bytevec_from_host$ENQ),
								.DEQ(f_bytevec_from_host$DEQ),
								.CLR(f_bytevec_from_host$CLR),
								.D_OUT(f_bytevec_from_host$D_OUT),
								.FULL_N(f_bytevec_from_host$FULL_N),
								.EMPTY_N(f_bytevec_from_host$EMPTY_N));

  // submodule f_bytevec_to_host
  FIFO2 #(.width(32'd656), .guarded(32'd1)) f_bytevec_to_host(.RST(RST_N),
							      .CLK(CLK),
							      .D_IN(f_bytevec_to_host$D_IN),
							      .ENQ(f_bytevec_to_host$ENQ),
							      .DEQ(f_bytevec_to_host$DEQ),
							      .CLR(f_bytevec_to_host$CLR),
							      .D_OUT(f_bytevec_to_host$D_OUT),
							      .FULL_N(f_bytevec_to_host$FULL_N),
							      .EMPTY_N(f_bytevec_to_host$EMPTY_N));

  // submodule f_echo
  FIFO2 #(.width(32'd8), .guarded(32'd1)) f_echo(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(f_echo$D_IN),
						 .ENQ(f_echo$ENQ),
						 .DEQ(f_echo$DEQ),
						 .CLR(f_echo$CLR),
						 .D_OUT(f_echo$D_OUT),
						 .FULL_N(f_echo$FULL_N),
						 .EMPTY_N(f_echo$EMPTY_N));

  // submodule f_from_console
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd8),
	      .p3cntr_width(32'd3),
	      .guarded(32'd1)) f_from_console(.RST(RST_N),
					      .CLK(CLK),
					      .D_IN(f_from_console$D_IN),
					      .ENQ(f_from_console$ENQ),
					      .DEQ(f_from_console$DEQ),
					      .CLR(f_from_console$CLR),
					      .D_OUT(f_from_console$D_OUT),
					      .FULL_N(f_from_console$FULL_N),
					      .EMPTY_N(f_from_console$EMPTY_N));

  // submodule f_to_verifier
  FIFO2 #(.width(32'd608), .guarded(32'd1)) f_to_verifier(.RST(RST_N),
							  .CLK(CLK),
							  .D_IN(f_to_verifier$D_IN),
							  .ENQ(f_to_verifier$ENQ),
							  .DEQ(f_to_verifier$DEQ),
							  .CLR(f_to_verifier$CLR),
							  .D_OUT(f_to_verifier$D_OUT),
							  .FULL_N(f_to_verifier$FULL_N),
							  .EMPTY_N(f_to_verifier$EMPTY_N));

  // rule RL_rl_rx_from_console
  assign CAN_FIRE_RL_rl_rx_from_console =
	     f_bytevec_from_host$EMPTY_N && f_from_console$FULL_N &&
	     f_bytevec_from_host$D_OUT[39:32] == 8'd1 &&
	     !rg_shutdown ;
  assign WILL_FIRE_RL_rl_rx_from_console = CAN_FIRE_RL_rl_rx_from_console ;

  // rule RL_rl_tx_to_verifier
  assign CAN_FIRE_RL_rl_tx_to_verifier =
	     f_to_verifier$EMPTY_N && f_bytevec_to_host$FULL_N &&
	     rg_credits_to_verifier != 8'd0 &&
	     !rg_shutdown ;
  assign WILL_FIRE_RL_rl_tx_to_verifier =
	     CAN_FIRE_RL_rl_tx_to_verifier &&
	     !WILL_FIRE_RL_rl_rx_from_console &&
	     !EN_from_console_get ;

  // rule RL_rl_tx_echo
  assign CAN_FIRE_RL_rl_tx_echo =
	     f_bytevec_to_host$FULL_N && f_echo$EMPTY_N && !rg_shutdown ;
  assign WILL_FIRE_RL_rl_tx_echo =
	     CAN_FIRE_RL_rl_tx_echo && !WILL_FIRE_RL_rl_tx_to_verifier &&
	     !EN_from_console_get ;

  // rule RL_rl_rx_echo
  assign CAN_FIRE_RL_rl_rx_echo =
	     f_bytevec_from_host$EMPTY_N &&
	     (f_bytevec_from_host$D_OUT[55:48] == 8'h04 ||
	      f_bytevec_from_host$D_OUT[55:48] == 8'h43 ||
	      f_echo$FULL_N) &&
	     f_bytevec_from_host$D_OUT[39:32] == 8'd0 &&
	     !rg_shutdown ;
  assign WILL_FIRE_RL_rl_rx_echo =
	     CAN_FIRE_RL_rl_rx_echo && !WILL_FIRE_RL_rl_tx_to_verifier ;

  // rule RL_rl_tx_credit
  assign CAN_FIRE_RL_rl_tx_credit =
	     (credit_timeout_ctr != 20'd0 || f_bytevec_to_host$FULL_N) &&
	     rg_avail_f_from_console != 8'd0 ;
  assign WILL_FIRE_RL_rl_tx_credit =
	     CAN_FIRE_RL_rl_tx_credit && !WILL_FIRE_RL_rl_tx_echo &&
	     !WILL_FIRE_RL_rl_tx_to_verifier &&
	     !EN_from_console_get ;

  // inputs to muxes for submodule ports
  assign MUX_f_bytevec_to_host$enq_1__SEL_1 =
	     WILL_FIRE_RL_rl_tx_credit && credit_timeout_ctr == 20'd0 ;
  assign MUX_credit_timeout_ctr$write_1__VAL_1 =
	     (credit_timeout_ctr == 20'd0) ?
	       20'd10 :
	       credit_timeout_ctr - 20'd1 ;
  assign MUX_f_bytevec_to_host$enq_1__VAL_1 =
	     { 608'd67, rg_avail_f_from_console, 40'd3 } ;
  assign MUX_f_bytevec_to_host$enq_1__VAL_2 =
	     { f_to_verifier$D_OUT[575:0],
	       f_to_verifier$D_OUT[607:576],
	       rg_avail_f_from_console,
	       40'h010000004E } ;
  assign MUX_f_bytevec_to_host$enq_1__VAL_3 =
	     { 600'd0, f_echo$D_OUT, rg_avail_f_from_console, 40'd3 } ;
  assign MUX_rg_avail_f_from_console$write_1__VAL_5 =
	     rg_avail_f_from_console + 8'd1 ;
  assign MUX_rg_credits_to_verifier$write_1__VAL_2 =
	     rg_credits_to_verifier + f_bytevec_from_host$D_OUT[47:40] ;
  assign MUX_rg_credits_to_verifier$write_1__VAL_3 =
	     rg_credits_to_verifier - 8'd1 ;

  // register credit_timeout_ctr
  assign credit_timeout_ctr$D_IN =
	     WILL_FIRE_RL_rl_tx_credit ?
	       MUX_credit_timeout_ctr$write_1__VAL_1 :
	       20'd10 ;
  assign credit_timeout_ctr$EN =
	     WILL_FIRE_RL_rl_tx_credit || WILL_FIRE_RL_rl_tx_echo ||
	     WILL_FIRE_RL_rl_tx_to_verifier ;

  // register rg_avail_f_from_console
  always@(EN_init or
	  MUX_f_bytevec_to_host$enq_1__SEL_1 or
	  WILL_FIRE_RL_rl_tx_echo or
	  WILL_FIRE_RL_rl_tx_to_verifier or
	  EN_from_console_get or MUX_rg_avail_f_from_console$write_1__VAL_5)
  case (1'b1)
    EN_init: rg_avail_f_from_console$D_IN = 8'd7;
    MUX_f_bytevec_to_host$enq_1__SEL_1 || WILL_FIRE_RL_rl_tx_echo ||
    WILL_FIRE_RL_rl_tx_to_verifier:
	rg_avail_f_from_console$D_IN = 8'd0;
    EN_from_console_get:
	rg_avail_f_from_console$D_IN =
	    MUX_rg_avail_f_from_console$write_1__VAL_5;
    default: rg_avail_f_from_console$D_IN =
		 8'b10101010 /* unspecified value */ ;
  endcase
  assign rg_avail_f_from_console$EN =
	     WILL_FIRE_RL_rl_tx_credit && credit_timeout_ctr == 20'd0 ||
	     EN_from_console_get ||
	     WILL_FIRE_RL_rl_tx_echo ||
	     WILL_FIRE_RL_rl_tx_to_verifier ||
	     EN_init ;

  // register rg_credits_to_verifier
  always@(EN_init or
	  WILL_FIRE_RL_rl_rx_echo or
	  MUX_rg_credits_to_verifier$write_1__VAL_2 or
	  WILL_FIRE_RL_rl_tx_to_verifier or
	  MUX_rg_credits_to_verifier$write_1__VAL_3 or
	  WILL_FIRE_RL_rl_rx_from_console)
  case (1'b1)
    EN_init: rg_credits_to_verifier$D_IN = 8'd1;
    WILL_FIRE_RL_rl_rx_echo:
	rg_credits_to_verifier$D_IN =
	    MUX_rg_credits_to_verifier$write_1__VAL_2;
    WILL_FIRE_RL_rl_tx_to_verifier:
	rg_credits_to_verifier$D_IN =
	    MUX_rg_credits_to_verifier$write_1__VAL_3;
    WILL_FIRE_RL_rl_rx_from_console:
	rg_credits_to_verifier$D_IN =
	    MUX_rg_credits_to_verifier$write_1__VAL_2;
    default: rg_credits_to_verifier$D_IN =
		 8'b10101010 /* unspecified value */ ;
  endcase
  assign rg_credits_to_verifier$EN =
	     WILL_FIRE_RL_rl_rx_echo || WILL_FIRE_RL_rl_rx_from_console ||
	     WILL_FIRE_RL_rl_tx_to_verifier ||
	     EN_init ;

  // register rg_shutdown
  assign rg_shutdown$D_IN = !EN_init ;
  assign rg_shutdown$EN =
	     WILL_FIRE_RL_rl_rx_echo &&
	     f_bytevec_from_host$D_OUT[55:48] == 8'h04 ||
	     EN_init ;

  // register test_succeeded
  assign test_succeeded$D_IN = 1'd1 ;
  assign test_succeeded$EN = WILL_FIRE_RL_rl_tx_echo ;

  // submodule f_bytevec_from_host
  assign f_bytevec_from_host$D_IN = client_response_put ;
  assign f_bytevec_from_host$ENQ = EN_client_response_put ;
  assign f_bytevec_from_host$DEQ =
	     WILL_FIRE_RL_rl_rx_echo || WILL_FIRE_RL_rl_rx_from_console ;
  assign f_bytevec_from_host$CLR = EN_init ;

  // submodule f_bytevec_to_host
  always@(MUX_f_bytevec_to_host$enq_1__SEL_1 or
	  MUX_f_bytevec_to_host$enq_1__VAL_1 or
	  WILL_FIRE_RL_rl_tx_to_verifier or
	  MUX_f_bytevec_to_host$enq_1__VAL_2 or
	  WILL_FIRE_RL_rl_tx_echo or MUX_f_bytevec_to_host$enq_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_f_bytevec_to_host$enq_1__SEL_1:
	  f_bytevec_to_host$D_IN = MUX_f_bytevec_to_host$enq_1__VAL_1;
      WILL_FIRE_RL_rl_tx_to_verifier:
	  f_bytevec_to_host$D_IN = MUX_f_bytevec_to_host$enq_1__VAL_2;
      WILL_FIRE_RL_rl_tx_echo:
	  f_bytevec_to_host$D_IN = MUX_f_bytevec_to_host$enq_1__VAL_3;
      default: f_bytevec_to_host$D_IN =
		   656'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign f_bytevec_to_host$ENQ =
	     WILL_FIRE_RL_rl_tx_credit && credit_timeout_ctr == 20'd0 ||
	     WILL_FIRE_RL_rl_tx_to_verifier ||
	     WILL_FIRE_RL_rl_tx_echo ;
  assign f_bytevec_to_host$DEQ = EN_client_request_get ;
  assign f_bytevec_to_host$CLR = EN_init ;

  // submodule f_echo
  assign f_echo$D_IN = f_bytevec_from_host$D_OUT[55:48] ;
  assign f_echo$ENQ =
	     WILL_FIRE_RL_rl_rx_echo &&
	     f_bytevec_from_host$D_OUT[55:48] != 8'h04 &&
	     f_bytevec_from_host$D_OUT[55:48] != 8'h43 ;
  assign f_echo$DEQ = WILL_FIRE_RL_rl_tx_echo ;
  assign f_echo$CLR = EN_init ;

  // submodule f_from_console
  assign f_from_console$D_IN = f_bytevec_from_host$D_OUT[55:48] ;
  assign f_from_console$ENQ = CAN_FIRE_RL_rl_rx_from_console ;
  assign f_from_console$DEQ = EN_from_console_get ;
  assign f_from_console$CLR = EN_init ;

  // submodule f_to_verifier
  assign f_to_verifier$D_IN = to_verifier_put ;
  assign f_to_verifier$ENQ = EN_to_verifier_put ;
  assign f_to_verifier$DEQ = WILL_FIRE_RL_rl_tx_to_verifier ;
  assign f_to_verifier$CLR = EN_init ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        credit_timeout_ctr <= `BSV_ASSIGNMENT_DELAY 20'd0;
	rg_avail_f_from_console <= `BSV_ASSIGNMENT_DELAY 8'd7;
	rg_credits_to_verifier <= `BSV_ASSIGNMENT_DELAY 8'd1;
	rg_shutdown <= `BSV_ASSIGNMENT_DELAY 1'd0;
	test_succeeded <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (credit_timeout_ctr$EN)
	  credit_timeout_ctr <= `BSV_ASSIGNMENT_DELAY credit_timeout_ctr$D_IN;
	if (rg_avail_f_from_console$EN)
	  rg_avail_f_from_console <= `BSV_ASSIGNMENT_DELAY
	      rg_avail_f_from_console$D_IN;
	if (rg_credits_to_verifier$EN)
	  rg_credits_to_verifier <= `BSV_ASSIGNMENT_DELAY
	      rg_credits_to_verifier$D_IN;
	if (rg_shutdown$EN)
	  rg_shutdown <= `BSV_ASSIGNMENT_DELAY rg_shutdown$D_IN;
	if (test_succeeded$EN)
	  test_succeeded <= `BSV_ASSIGNMENT_DELAY test_succeeded$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    credit_timeout_ctr = 20'hAAAAA;
    rg_avail_f_from_console = 8'hAA;
    rg_credits_to_verifier = 8'hAA;
    rg_shutdown = 1'h0;
    test_succeeded = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkBytevec_Mux_HW_Side

